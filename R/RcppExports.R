# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Linear combinations of submatrices of an array
#' 
#' Computes a matrix of expected values based on an array X of predictors,
#' vector beta of regression coefficients, the outer product of the a and b
#' random effects, and the third order effects U and V.
#' 
#' @usage Xbeta_cpp(X, beta)
#' @param X a N length list filled with n by n by p arrays
#' @param beta a p by 1 vector
#' @param ab a n by n matrix calculated by taking the outer 
#' product of the a and b random effect vectors
#' @param U an n by k matrix of multiplicative row effects
#' @param V an n by k matrix of multiplicative column effects
#' @return An n by n by N array
#' @author Peter Hoff, Shahryar Minhas
#' @export get_EZ_cpp
get_EZ_cpp <- function(Xlist, beta, ab, U, V) {
    .Call('amen_get_EZ_cpp', PACKAGE = 'amen', Xlist, beta, ab, U, V)
}

#' Gibbs sampling of additive row and column effects and regression coefficient
#' with independent replicate relational data
#' 
#' Simulates from the joint full conditional distribution of (a,b,beta),
#' assuming same additive row and column effects and regression coefficient
#' across replicates. 
#' 
#' 
#' @usage rbeta_ab_rep_cpp(Z.T,Sab,rho,X.T,s2=1)
#' @param Z.T n x n x T array, with the third dimension for replicates.
#' Each slice of the array is a (latent) normal relational matrix, with
#' multiplicative effects subtracted out
#' @param XrCube n x p x T row covariate array generated within ame_repL fn
#' @param XcCube n x p x T column covariate array generated within ame_repL fn
#' @param mXCube n^2 x p x T design array generated within ame_repL fn
#' @param mXtCube n^2 x p x T transposed design array generated within ame_repL fn
#' @param xxCube p x p x T regression sum of squares array generated within ame_repl fn
#' @param xxTCube p x p x T transposed regression sum of squares array generated 
#' within ame_repl fn
#' @param iSe2 variance matrix
#' @param Sabs row and column covariance
#' @param k dimensions for row and column random effects
#' @param G eigenvalue calcs from Sab
#' @param e n x k gaussian error matrix
#' @param colE column sums of e
#' @return \item{beta}{regression coefficients} \item{a}{additive row effects}
#' \item{b}{additive column effects}
#' @author Peter Hoff, Yanjun He, Shahryar Minhas
#' @export rbeta_ab_rep_fc_cpp
rbeta_ab_rep_fc_cpp <- function(zCube, XrCube, XcCube, mXCube, mXtCube, xxCube, xxTCube, iSe2, Sabs, k, G) {
    .Call('amen_rbeta_ab_rep_fc_cpp', PACKAGE = 'amen', zCube, XrCube, XcCube, mXCube, mXtCube, xxCube, xxTCube, iSe2, Sabs, k, G)
}

#' Metropolis update for dyadic correlation with independent replicate data
#' 
#' Metropolis update for dyadic correlation with independent replicate data. 
#' 
#' 
#' @usage rrho_mh_rep_cpp(E.T, rho, s2 = 1)
#' @param E.T Array of square residual relational matrix series. The third
#' dimension of the array is for different replicates. Each slice of the array
#' according to the third dimension is a square residual relational matrix. 
#' @param rho current value of rho
#' @param s2 current value of s2
#' @return a new value of rho
#' @author Peter Hoff, Yanjun He, Shahryar Minhas
#' @export rrho_mh_rep_cpp
rrho_mh_rep_cpp <- function(ET, rho, s2) {
    .Call('amen_rrho_mh_rep_cpp', PACKAGE = 'amen', ET, rho, s2)
}

#' Gibbs update for dyadic variance with independent replicate relational data
#' 
#' Gibbs update for dyadic variance with independent replicate relational data
#' 
#' 
#' @usage rs2_rep_fc_cpp(E.T, rhoMat=solve(matrix(c(1,rho,rho,1),2,2)) )
#' @param E.T Array of square residual relational matrix series. The third
#' dimension of the array is for different replicates. Each slice of the array
#' according to the third dimension is a square residual relational matrix
#' @param rhoMat inverted off-diagnoal matrix of rho
#' @return a new value of s2
#' @author Peter Hoff, Yanjun He, Shahryar Minhas
#' @export rs2_rep_fc_cpp
rs2_rep_fc_cpp <- function(ET, rhoMat) {
    .Call('amen_rs2_rep_fc_cpp', PACKAGE = 'amen', ET, rhoMat)
}

#' Simulation from a Wishart distribution
#' 
#' Simulates a random Wishart-distributed matrix
#' 
#' 
#' @usage rwish_cpp(S0, nu = dim(S0)[1] + 1)
#' @param S0 a positive definite matrix
#' @param nu a positive integer
#' @return a positive definite matrix
#' @author Peter Hoff, Shahryar Minhas
#' @examples
#' 
#' ## The expectation is S0*nu
#' 
#' S0<-rwish(diag(3)) 
#' SS<-matrix(0,3,3) 
#' for(s in 1:1000) { SS<-SS+rwish(S0,5) }
#' SS/s 
#' S0*5
#' 
#' @export rwish_cpp
rwish_cpp <- function(S0, nu) {
    .Call('amen_rwish_cpp', PACKAGE = 'amen', S0, nu)
}

#' Gibbs sampling of U and V
#' 
#' A Gibbs sampler for updating the multiplicative effect matrices U and V,
#' assuming they are the same across replicates. 
#' 
#' 
#' @usage rUV_rep_fc_cpp(ET,U,V,rho,s2=1,maxmargin=1e-6,shrink=TRUE,rLoopIDs=sample(1:R)-1)
#' @param ET Array of square residual relational matrix series with additive
#' effects and covariates subtracted out. The third dimension of the array is
#' for different replicates. Each slice of the array according to the third
#' dimension is a square residual relational matrix. 
#' @param U current value of U
#' @param V current value of V
#' @param rho dyadic correlation
#' @param s2 dyadic variance
#' @param iSe2 rho dyadic variance combo
#' @param maxmargin small float
#' @param shrink adaptively shrink the factors with a hierarchical prior
#' @param rLoopIDs shuffled vector of latent space dimension sequence
#' @return \item{U}{a new value of U} \item{V}{a new value of V}
#' @author Peter Hoff, Yanjun He, Shahryar Minhas
#' @export rUV_rep_fc_cpp
rUV_rep_fc_cpp <- function(ET, U, V, rho, s2, iSe2, maxmargin, shrink, rLoopIDs) {
    .Call('amen_rUV_rep_fc_cpp', PACKAGE = 'amen', ET, U, V, rho, s2, iSe2, maxmargin, shrink, rLoopIDs)
}

#' Gibbs sampling of U and V
#' 
#' A Gibbs sampler for updating the multiplicative effect matrices U and V
#' in the symmetric case. In this case \code{U\%*\%t(V)} is symmetric, so
#' this is parameterized as \code{V=U\%*\%L} where \code{L} is the 
#' diagonal matrix of eigenvalues of \code{U\%*\%t(V)}. 
#' 
#' @usage rUV_sym_fc_cpp(E, U, V, s2 = 1, shrink=TRUE)
#' @param E square residual relational matrix
#' @param U current value of U
#' @param V current value of V
#' @param s2 dyadic variance
#' @param shrink adaptively shrink the factors with a hierarchical prior
#' @param uLoopIDs vector of rows to iteratively loop through
#' when updating U
#' @return \item{U}{a new value of U} \item{V}{a new value of V}
#' @author Peter Hoff, Shahryar Minhas
#' @examples
#' 
#' U0<-matrix(rnorm(30,2),30,2) ; V0<-U0%*%diag(c(3,-2)) 
#' E<- U0%*%t(V0) + matrix(rnorm(30^2),30,30) 
#' rUV_sym_fc_cpp(E,U0,V0,s2=1,shrink=TRUE,uLoopIDs=rep( sample(1:nrow(E)),4)-1 )
#' 
#' @export rUV_sym_fc_cpp
rUV_sym_fc_cpp <- function(E, U, V, s2, shrink, uLoopIDs) {
    .Call('amen_rUV_sym_fc_cpp', PACKAGE = 'amen', E, U, V, s2, shrink, uLoopIDs)
}

#' Linear combinations of submatrices of an array
#' 
#' Computes a matrix of expected values based on an array X of predictors and a
#' vector beta of regression coefficients.
#' 
#' 
#' @usage Xbeta_cpp(X, beta)
#' @param X an n by n by p array
#' @param beta a p by 1 vector
#' @return An n by n matrix
#' @author Peter Hoff, Shahryar Minhas
#' @export Xbeta_cpp
Xbeta_cpp <- function(X, beta) {
    .Call('amen_Xbeta_cpp', PACKAGE = 'amen', X, beta)
}

